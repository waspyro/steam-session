/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";

export const protobufPackage = "";

export interface CMsgClientFriendMsg {
  steamid: number;
  chatEntryType: number;
  message: Buffer;
  rtime32ServerTimestamp: number;
  echoToSender: boolean;
}

export interface CMsgClientFriendMsgIncoming {
  steamidFrom: number;
  chatEntryType: number;
  fromLimitedAccount: boolean;
  message: Buffer;
  rtime32ServerTimestamp: number;
}

export interface CMsgClientAddFriend {
  steamidToAdd: number;
  accountnameOrEmailToAdd: string;
}

export interface CMsgClientAddFriendResponse {
  eresult: number;
  steamIdAdded: number;
  personaNameAdded: string;
}

export interface CMsgClientRemoveFriend {
  friendid: number;
}

export interface CMsgClientHideFriend {
  friendid: number;
  hide: boolean;
}

export interface CMsgClientFriendsList {
  bincremental: boolean;
  friends: CMsgClientFriendsList_Friend[];
  maxFriendCount: number;
  activeFriendCount: number;
  friendsLimitHit: boolean;
}

export interface CMsgClientFriendsList_Friend {
  ulfriendid: number;
  efriendrelationship: number;
}

export interface CMsgClientFriendsGroupsList {
  bremoval: boolean;
  bincremental: boolean;
  friendGroups: CMsgClientFriendsGroupsList_FriendGroup[];
  memberships: CMsgClientFriendsGroupsList_FriendGroupsMembership[];
}

export interface CMsgClientFriendsGroupsList_FriendGroup {
  nGroupID: number;
  strGroupName: string;
}

export interface CMsgClientFriendsGroupsList_FriendGroupsMembership {
  ulSteamID: number;
  nGroupID: number;
}

export interface CMsgClientPlayerNicknameList {
  removal: boolean;
  incremental: boolean;
  nicknames: CMsgClientPlayerNicknameList_PlayerNickname[];
}

export interface CMsgClientPlayerNicknameList_PlayerNickname {
  steamid: number;
  nickname: string;
}

export interface CMsgClientSetPlayerNickname {
  steamid: number;
  nickname: string;
}

export interface CMsgClientSetPlayerNicknameResponse {
  eresult: number;
}

export interface CMsgClientRequestFriendData {
  personaStateRequested: number;
  friends: number[];
}

export interface CMsgClientChangeStatus {
  personaState: number;
  playerName: string;
  isAutoGeneratedName: boolean;
  highPriority: boolean;
  personaSetByUser: boolean;
  personaStateFlags: number;
  needPersonaResponse: boolean;
  isClientIdle: boolean;
}

export interface CMsgPersonaChangeResponse {
  result: number;
  playerName: string;
}

export interface CMsgClientPersonaState {
  statusFlags: number;
  friends: CMsgClientPersonaState_Friend[];
}

export interface CMsgClientPersonaState_Friend {
  friendid: number;
  personaState: number;
  gamePlayedAppId: number;
  gameServerIp: number;
  gameServerPort: number;
  personaStateFlags: number;
  onlineSessionInstances: number;
  personaSetByUser: boolean;
  playerName: string;
  queryPort: number;
  steamidSource: number;
  avatarHash: Buffer;
  lastLogoff: number;
  lastLogon: number;
  lastSeenOnline: number;
  clanRank: number;
  gameName: string;
  gameid: number;
  gameDataBlob: Buffer;
  clanData: CMsgClientPersonaState_Friend_ClanData | undefined;
  clanTag: string;
  richPresence: CMsgClientPersonaState_Friend_KV[];
  broadcastId: number;
  gameLobbyId: number;
  watchingBroadcastAccountid: number;
  watchingBroadcastAppid: number;
  watchingBroadcastViewers: number;
  watchingBroadcastTitle: string;
  isCommunityBanned: boolean;
  playerNamePendingReview: boolean;
  avatarPendingReview: boolean;
}

export interface CMsgClientPersonaState_Friend_ClanData {
  oggAppId: number;
  chatGroupId: number;
}

export interface CMsgClientPersonaState_Friend_KV {
  key: string;
  value: string;
}

export interface CMsgClientFriendProfileInfo {
  steamidFriend: number;
}

export interface CMsgClientFriendProfileInfoResponse {
  eresult: number;
  steamidFriend: number;
  timeCreated: number;
  realName: string;
  cityName: string;
  stateName: string;
  countryName: string;
  headline: string;
  summary: string;
}

export interface CMsgClientCreateFriendsGroup {
  steamid: number;
  groupname: string;
  steamidFriends: number[];
}

export interface CMsgClientCreateFriendsGroupResponse {
  eresult: number;
  groupid: number;
}

export interface CMsgClientDeleteFriendsGroup {
  steamid: number;
  groupid: number;
}

export interface CMsgClientDeleteFriendsGroupResponse {
  eresult: number;
}

export interface CMsgClientManageFriendsGroup {
  groupid: number;
  groupname: string;
  steamidFriendsAdded: number[];
  steamidFriendsRemoved: number[];
}

export interface CMsgClientManageFriendsGroupResponse {
  eresult: number;
}

export interface CMsgClientAddFriendToGroup {
  groupid: number;
  steamiduser: number;
}

export interface CMsgClientAddFriendToGroupResponse {
  eresult: number;
}

export interface CMsgClientRemoveFriendFromGroup {
  groupid: number;
  steamiduser: number;
}

export interface CMsgClientRemoveFriendFromGroupResponse {
  eresult: number;
}

export interface CMsgClientGetEmoticonList {
}

export interface CMsgClientEmoticonList {
  emoticons: CMsgClientEmoticonList_Emoticon[];
  stickers: CMsgClientEmoticonList_Sticker[];
  effects: CMsgClientEmoticonList_Effect[];
}

export interface CMsgClientEmoticonList_Emoticon {
  name: string;
  count: number;
  timeLastUsed: number;
  useCount: number;
  timeReceived: number;
  appid: number;
}

export interface CMsgClientEmoticonList_Sticker {
  name: string;
  count: number;
  timeReceived: number;
  appid: number;
  timeLastUsed: number;
  useCount: number;
}

export interface CMsgClientEmoticonList_Effect {
  name: string;
  count: number;
  timeReceived: number;
  infiniteUse: boolean;
  appid: number;
}

function createBaseCMsgClientFriendMsg(): CMsgClientFriendMsg {
  return { steamid: 0, chatEntryType: 0, message: Buffer.alloc(0), rtime32ServerTimestamp: 0, echoToSender: false };
}

export const CMsgClientFriendMsg = {
  encode(message: CMsgClientFriendMsg, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.steamid !== 0) {
      writer.uint32(9).fixed64(message.steamid);
    }
    if (message.chatEntryType !== 0) {
      writer.uint32(16).int32(message.chatEntryType);
    }
    if (message.message.length !== 0) {
      writer.uint32(26).bytes(message.message);
    }
    if (message.rtime32ServerTimestamp !== 0) {
      writer.uint32(37).fixed32(message.rtime32ServerTimestamp);
    }
    if (message.echoToSender === true) {
      writer.uint32(40).bool(message.echoToSender);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientFriendMsg {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientFriendMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.steamid = longToNumber(reader.fixed64() as Long);
          break;
        case 2:
          message.chatEntryType = reader.int32();
          break;
        case 3:
          message.message = reader.bytes() as Buffer;
          break;
        case 4:
          message.rtime32ServerTimestamp = reader.fixed32();
          break;
        case 5:
          message.echoToSender = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgClientFriendMsg {
    return {
      steamid: isSet(object.steamid) ? Number(object.steamid) : 0,
      chatEntryType: isSet(object.chatEntryType) ? Number(object.chatEntryType) : 0,
      message: isSet(object.message) ? Buffer.from(bytesFromBase64(object.message)) : Buffer.alloc(0),
      rtime32ServerTimestamp: isSet(object.rtime32ServerTimestamp) ? Number(object.rtime32ServerTimestamp) : 0,
      echoToSender: isSet(object.echoToSender) ? Boolean(object.echoToSender) : false,
    };
  },

  toJSON(message: CMsgClientFriendMsg): unknown {
    const obj: any = {};
    message.steamid !== undefined && (obj.steamid = Math.round(message.steamid));
    message.chatEntryType !== undefined && (obj.chatEntryType = Math.round(message.chatEntryType));
    message.message !== undefined &&
      (obj.message = base64FromBytes(message.message !== undefined ? message.message : Buffer.alloc(0)));
    message.rtime32ServerTimestamp !== undefined &&
      (obj.rtime32ServerTimestamp = Math.round(message.rtime32ServerTimestamp));
    message.echoToSender !== undefined && (obj.echoToSender = message.echoToSender);
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientFriendMsg>, I>>(base?: I): CMsgClientFriendMsg {
    return CMsgClientFriendMsg.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientFriendMsg>, I>>(object: I): CMsgClientFriendMsg {
    const message = createBaseCMsgClientFriendMsg();
    message.steamid = object.steamid ?? 0;
    message.chatEntryType = object.chatEntryType ?? 0;
    message.message = object.message ?? Buffer.alloc(0);
    message.rtime32ServerTimestamp = object.rtime32ServerTimestamp ?? 0;
    message.echoToSender = object.echoToSender ?? false;
    return message;
  },
};

function createBaseCMsgClientFriendMsgIncoming(): CMsgClientFriendMsgIncoming {
  return {
    steamidFrom: 0,
    chatEntryType: 0,
    fromLimitedAccount: false,
    message: Buffer.alloc(0),
    rtime32ServerTimestamp: 0,
  };
}

export const CMsgClientFriendMsgIncoming = {
  encode(message: CMsgClientFriendMsgIncoming, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.steamidFrom !== 0) {
      writer.uint32(9).fixed64(message.steamidFrom);
    }
    if (message.chatEntryType !== 0) {
      writer.uint32(16).int32(message.chatEntryType);
    }
    if (message.fromLimitedAccount === true) {
      writer.uint32(24).bool(message.fromLimitedAccount);
    }
    if (message.message.length !== 0) {
      writer.uint32(34).bytes(message.message);
    }
    if (message.rtime32ServerTimestamp !== 0) {
      writer.uint32(45).fixed32(message.rtime32ServerTimestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientFriendMsgIncoming {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientFriendMsgIncoming();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.steamidFrom = longToNumber(reader.fixed64() as Long);
          break;
        case 2:
          message.chatEntryType = reader.int32();
          break;
        case 3:
          message.fromLimitedAccount = reader.bool();
          break;
        case 4:
          message.message = reader.bytes() as Buffer;
          break;
        case 5:
          message.rtime32ServerTimestamp = reader.fixed32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgClientFriendMsgIncoming {
    return {
      steamidFrom: isSet(object.steamidFrom) ? Number(object.steamidFrom) : 0,
      chatEntryType: isSet(object.chatEntryType) ? Number(object.chatEntryType) : 0,
      fromLimitedAccount: isSet(object.fromLimitedAccount) ? Boolean(object.fromLimitedAccount) : false,
      message: isSet(object.message) ? Buffer.from(bytesFromBase64(object.message)) : Buffer.alloc(0),
      rtime32ServerTimestamp: isSet(object.rtime32ServerTimestamp) ? Number(object.rtime32ServerTimestamp) : 0,
    };
  },

  toJSON(message: CMsgClientFriendMsgIncoming): unknown {
    const obj: any = {};
    message.steamidFrom !== undefined && (obj.steamidFrom = Math.round(message.steamidFrom));
    message.chatEntryType !== undefined && (obj.chatEntryType = Math.round(message.chatEntryType));
    message.fromLimitedAccount !== undefined && (obj.fromLimitedAccount = message.fromLimitedAccount);
    message.message !== undefined &&
      (obj.message = base64FromBytes(message.message !== undefined ? message.message : Buffer.alloc(0)));
    message.rtime32ServerTimestamp !== undefined &&
      (obj.rtime32ServerTimestamp = Math.round(message.rtime32ServerTimestamp));
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientFriendMsgIncoming>, I>>(base?: I): CMsgClientFriendMsgIncoming {
    return CMsgClientFriendMsgIncoming.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientFriendMsgIncoming>, I>>(object: I): CMsgClientFriendMsgIncoming {
    const message = createBaseCMsgClientFriendMsgIncoming();
    message.steamidFrom = object.steamidFrom ?? 0;
    message.chatEntryType = object.chatEntryType ?? 0;
    message.fromLimitedAccount = object.fromLimitedAccount ?? false;
    message.message = object.message ?? Buffer.alloc(0);
    message.rtime32ServerTimestamp = object.rtime32ServerTimestamp ?? 0;
    return message;
  },
};

function createBaseCMsgClientAddFriend(): CMsgClientAddFriend {
  return { steamidToAdd: 0, accountnameOrEmailToAdd: "" };
}

export const CMsgClientAddFriend = {
  encode(message: CMsgClientAddFriend, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.steamidToAdd !== 0) {
      writer.uint32(9).fixed64(message.steamidToAdd);
    }
    if (message.accountnameOrEmailToAdd !== "") {
      writer.uint32(18).string(message.accountnameOrEmailToAdd);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientAddFriend {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientAddFriend();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.steamidToAdd = longToNumber(reader.fixed64() as Long);
          break;
        case 2:
          message.accountnameOrEmailToAdd = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgClientAddFriend {
    return {
      steamidToAdd: isSet(object.steamidToAdd) ? Number(object.steamidToAdd) : 0,
      accountnameOrEmailToAdd: isSet(object.accountnameOrEmailToAdd) ? String(object.accountnameOrEmailToAdd) : "",
    };
  },

  toJSON(message: CMsgClientAddFriend): unknown {
    const obj: any = {};
    message.steamidToAdd !== undefined && (obj.steamidToAdd = Math.round(message.steamidToAdd));
    message.accountnameOrEmailToAdd !== undefined && (obj.accountnameOrEmailToAdd = message.accountnameOrEmailToAdd);
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientAddFriend>, I>>(base?: I): CMsgClientAddFriend {
    return CMsgClientAddFriend.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientAddFriend>, I>>(object: I): CMsgClientAddFriend {
    const message = createBaseCMsgClientAddFriend();
    message.steamidToAdd = object.steamidToAdd ?? 0;
    message.accountnameOrEmailToAdd = object.accountnameOrEmailToAdd ?? "";
    return message;
  },
};

function createBaseCMsgClientAddFriendResponse(): CMsgClientAddFriendResponse {
  return { eresult: 0, steamIdAdded: 0, personaNameAdded: "" };
}

export const CMsgClientAddFriendResponse = {
  encode(message: CMsgClientAddFriendResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eresult !== 0) {
      writer.uint32(8).int32(message.eresult);
    }
    if (message.steamIdAdded !== 0) {
      writer.uint32(17).fixed64(message.steamIdAdded);
    }
    if (message.personaNameAdded !== "") {
      writer.uint32(26).string(message.personaNameAdded);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientAddFriendResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientAddFriendResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.eresult = reader.int32();
          break;
        case 2:
          message.steamIdAdded = longToNumber(reader.fixed64() as Long);
          break;
        case 3:
          message.personaNameAdded = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgClientAddFriendResponse {
    return {
      eresult: isSet(object.eresult) ? Number(object.eresult) : 0,
      steamIdAdded: isSet(object.steamIdAdded) ? Number(object.steamIdAdded) : 0,
      personaNameAdded: isSet(object.personaNameAdded) ? String(object.personaNameAdded) : "",
    };
  },

  toJSON(message: CMsgClientAddFriendResponse): unknown {
    const obj: any = {};
    message.eresult !== undefined && (obj.eresult = Math.round(message.eresult));
    message.steamIdAdded !== undefined && (obj.steamIdAdded = Math.round(message.steamIdAdded));
    message.personaNameAdded !== undefined && (obj.personaNameAdded = message.personaNameAdded);
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientAddFriendResponse>, I>>(base?: I): CMsgClientAddFriendResponse {
    return CMsgClientAddFriendResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientAddFriendResponse>, I>>(object: I): CMsgClientAddFriendResponse {
    const message = createBaseCMsgClientAddFriendResponse();
    message.eresult = object.eresult ?? 0;
    message.steamIdAdded = object.steamIdAdded ?? 0;
    message.personaNameAdded = object.personaNameAdded ?? "";
    return message;
  },
};

function createBaseCMsgClientRemoveFriend(): CMsgClientRemoveFriend {
  return { friendid: 0 };
}

export const CMsgClientRemoveFriend = {
  encode(message: CMsgClientRemoveFriend, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.friendid !== 0) {
      writer.uint32(9).fixed64(message.friendid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientRemoveFriend {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientRemoveFriend();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.friendid = longToNumber(reader.fixed64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgClientRemoveFriend {
    return { friendid: isSet(object.friendid) ? Number(object.friendid) : 0 };
  },

  toJSON(message: CMsgClientRemoveFriend): unknown {
    const obj: any = {};
    message.friendid !== undefined && (obj.friendid = Math.round(message.friendid));
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientRemoveFriend>, I>>(base?: I): CMsgClientRemoveFriend {
    return CMsgClientRemoveFriend.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientRemoveFriend>, I>>(object: I): CMsgClientRemoveFriend {
    const message = createBaseCMsgClientRemoveFriend();
    message.friendid = object.friendid ?? 0;
    return message;
  },
};

function createBaseCMsgClientHideFriend(): CMsgClientHideFriend {
  return { friendid: 0, hide: false };
}

export const CMsgClientHideFriend = {
  encode(message: CMsgClientHideFriend, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.friendid !== 0) {
      writer.uint32(9).fixed64(message.friendid);
    }
    if (message.hide === true) {
      writer.uint32(16).bool(message.hide);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientHideFriend {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientHideFriend();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.friendid = longToNumber(reader.fixed64() as Long);
          break;
        case 2:
          message.hide = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgClientHideFriend {
    return {
      friendid: isSet(object.friendid) ? Number(object.friendid) : 0,
      hide: isSet(object.hide) ? Boolean(object.hide) : false,
    };
  },

  toJSON(message: CMsgClientHideFriend): unknown {
    const obj: any = {};
    message.friendid !== undefined && (obj.friendid = Math.round(message.friendid));
    message.hide !== undefined && (obj.hide = message.hide);
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientHideFriend>, I>>(base?: I): CMsgClientHideFriend {
    return CMsgClientHideFriend.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientHideFriend>, I>>(object: I): CMsgClientHideFriend {
    const message = createBaseCMsgClientHideFriend();
    message.friendid = object.friendid ?? 0;
    message.hide = object.hide ?? false;
    return message;
  },
};

function createBaseCMsgClientFriendsList(): CMsgClientFriendsList {
  return { bincremental: false, friends: [], maxFriendCount: 0, activeFriendCount: 0, friendsLimitHit: false };
}

export const CMsgClientFriendsList = {
  encode(message: CMsgClientFriendsList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.bincremental === true) {
      writer.uint32(8).bool(message.bincremental);
    }
    for (const v of message.friends) {
      CMsgClientFriendsList_Friend.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.maxFriendCount !== 0) {
      writer.uint32(24).uint32(message.maxFriendCount);
    }
    if (message.activeFriendCount !== 0) {
      writer.uint32(32).uint32(message.activeFriendCount);
    }
    if (message.friendsLimitHit === true) {
      writer.uint32(40).bool(message.friendsLimitHit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientFriendsList {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientFriendsList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.bincremental = reader.bool();
          break;
        case 2:
          message.friends.push(CMsgClientFriendsList_Friend.decode(reader, reader.uint32()));
          break;
        case 3:
          message.maxFriendCount = reader.uint32();
          break;
        case 4:
          message.activeFriendCount = reader.uint32();
          break;
        case 5:
          message.friendsLimitHit = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgClientFriendsList {
    return {
      bincremental: isSet(object.bincremental) ? Boolean(object.bincremental) : false,
      friends: Array.isArray(object?.friends)
        ? object.friends.map((e: any) => CMsgClientFriendsList_Friend.fromJSON(e))
        : [],
      maxFriendCount: isSet(object.maxFriendCount) ? Number(object.maxFriendCount) : 0,
      activeFriendCount: isSet(object.activeFriendCount) ? Number(object.activeFriendCount) : 0,
      friendsLimitHit: isSet(object.friendsLimitHit) ? Boolean(object.friendsLimitHit) : false,
    };
  },

  toJSON(message: CMsgClientFriendsList): unknown {
    const obj: any = {};
    message.bincremental !== undefined && (obj.bincremental = message.bincremental);
    if (message.friends) {
      obj.friends = message.friends.map((e) => e ? CMsgClientFriendsList_Friend.toJSON(e) : undefined);
    } else {
      obj.friends = [];
    }
    message.maxFriendCount !== undefined && (obj.maxFriendCount = Math.round(message.maxFriendCount));
    message.activeFriendCount !== undefined && (obj.activeFriendCount = Math.round(message.activeFriendCount));
    message.friendsLimitHit !== undefined && (obj.friendsLimitHit = message.friendsLimitHit);
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientFriendsList>, I>>(base?: I): CMsgClientFriendsList {
    return CMsgClientFriendsList.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientFriendsList>, I>>(object: I): CMsgClientFriendsList {
    const message = createBaseCMsgClientFriendsList();
    message.bincremental = object.bincremental ?? false;
    message.friends = object.friends?.map((e) => CMsgClientFriendsList_Friend.fromPartial(e)) || [];
    message.maxFriendCount = object.maxFriendCount ?? 0;
    message.activeFriendCount = object.activeFriendCount ?? 0;
    message.friendsLimitHit = object.friendsLimitHit ?? false;
    return message;
  },
};

function createBaseCMsgClientFriendsList_Friend(): CMsgClientFriendsList_Friend {
  return { ulfriendid: 0, efriendrelationship: 0 };
}

export const CMsgClientFriendsList_Friend = {
  encode(message: CMsgClientFriendsList_Friend, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ulfriendid !== 0) {
      writer.uint32(9).fixed64(message.ulfriendid);
    }
    if (message.efriendrelationship !== 0) {
      writer.uint32(16).uint32(message.efriendrelationship);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientFriendsList_Friend {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientFriendsList_Friend();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.ulfriendid = longToNumber(reader.fixed64() as Long);
          break;
        case 2:
          message.efriendrelationship = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgClientFriendsList_Friend {
    return {
      ulfriendid: isSet(object.ulfriendid) ? Number(object.ulfriendid) : 0,
      efriendrelationship: isSet(object.efriendrelationship) ? Number(object.efriendrelationship) : 0,
    };
  },

  toJSON(message: CMsgClientFriendsList_Friend): unknown {
    const obj: any = {};
    message.ulfriendid !== undefined && (obj.ulfriendid = Math.round(message.ulfriendid));
    message.efriendrelationship !== undefined && (obj.efriendrelationship = Math.round(message.efriendrelationship));
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientFriendsList_Friend>, I>>(base?: I): CMsgClientFriendsList_Friend {
    return CMsgClientFriendsList_Friend.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientFriendsList_Friend>, I>>(object: I): CMsgClientFriendsList_Friend {
    const message = createBaseCMsgClientFriendsList_Friend();
    message.ulfriendid = object.ulfriendid ?? 0;
    message.efriendrelationship = object.efriendrelationship ?? 0;
    return message;
  },
};

function createBaseCMsgClientFriendsGroupsList(): CMsgClientFriendsGroupsList {
  return { bremoval: false, bincremental: false, friendGroups: [], memberships: [] };
}

export const CMsgClientFriendsGroupsList = {
  encode(message: CMsgClientFriendsGroupsList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.bremoval === true) {
      writer.uint32(8).bool(message.bremoval);
    }
    if (message.bincremental === true) {
      writer.uint32(16).bool(message.bincremental);
    }
    for (const v of message.friendGroups) {
      CMsgClientFriendsGroupsList_FriendGroup.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.memberships) {
      CMsgClientFriendsGroupsList_FriendGroupsMembership.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientFriendsGroupsList {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientFriendsGroupsList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.bremoval = reader.bool();
          break;
        case 2:
          message.bincremental = reader.bool();
          break;
        case 3:
          message.friendGroups.push(CMsgClientFriendsGroupsList_FriendGroup.decode(reader, reader.uint32()));
          break;
        case 4:
          message.memberships.push(CMsgClientFriendsGroupsList_FriendGroupsMembership.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgClientFriendsGroupsList {
    return {
      bremoval: isSet(object.bremoval) ? Boolean(object.bremoval) : false,
      bincremental: isSet(object.bincremental) ? Boolean(object.bincremental) : false,
      friendGroups: Array.isArray(object?.friendGroups)
        ? object.friendGroups.map((e: any) => CMsgClientFriendsGroupsList_FriendGroup.fromJSON(e))
        : [],
      memberships: Array.isArray(object?.memberships)
        ? object.memberships.map((e: any) => CMsgClientFriendsGroupsList_FriendGroupsMembership.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgClientFriendsGroupsList): unknown {
    const obj: any = {};
    message.bremoval !== undefined && (obj.bremoval = message.bremoval);
    message.bincremental !== undefined && (obj.bincremental = message.bincremental);
    if (message.friendGroups) {
      obj.friendGroups = message.friendGroups.map((e) =>
        e ? CMsgClientFriendsGroupsList_FriendGroup.toJSON(e) : undefined
      );
    } else {
      obj.friendGroups = [];
    }
    if (message.memberships) {
      obj.memberships = message.memberships.map((e) =>
        e ? CMsgClientFriendsGroupsList_FriendGroupsMembership.toJSON(e) : undefined
      );
    } else {
      obj.memberships = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientFriendsGroupsList>, I>>(base?: I): CMsgClientFriendsGroupsList {
    return CMsgClientFriendsGroupsList.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientFriendsGroupsList>, I>>(object: I): CMsgClientFriendsGroupsList {
    const message = createBaseCMsgClientFriendsGroupsList();
    message.bremoval = object.bremoval ?? false;
    message.bincremental = object.bincremental ?? false;
    message.friendGroups = object.friendGroups?.map((e) => CMsgClientFriendsGroupsList_FriendGroup.fromPartial(e)) ||
      [];
    message.memberships =
      object.memberships?.map((e) => CMsgClientFriendsGroupsList_FriendGroupsMembership.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgClientFriendsGroupsList_FriendGroup(): CMsgClientFriendsGroupsList_FriendGroup {
  return { nGroupID: 0, strGroupName: "" };
}

export const CMsgClientFriendsGroupsList_FriendGroup = {
  encode(message: CMsgClientFriendsGroupsList_FriendGroup, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nGroupID !== 0) {
      writer.uint32(8).int32(message.nGroupID);
    }
    if (message.strGroupName !== "") {
      writer.uint32(18).string(message.strGroupName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientFriendsGroupsList_FriendGroup {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientFriendsGroupsList_FriendGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.nGroupID = reader.int32();
          break;
        case 2:
          message.strGroupName = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgClientFriendsGroupsList_FriendGroup {
    return {
      nGroupID: isSet(object.nGroupID) ? Number(object.nGroupID) : 0,
      strGroupName: isSet(object.strGroupName) ? String(object.strGroupName) : "",
    };
  },

  toJSON(message: CMsgClientFriendsGroupsList_FriendGroup): unknown {
    const obj: any = {};
    message.nGroupID !== undefined && (obj.nGroupID = Math.round(message.nGroupID));
    message.strGroupName !== undefined && (obj.strGroupName = message.strGroupName);
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientFriendsGroupsList_FriendGroup>, I>>(
    base?: I,
  ): CMsgClientFriendsGroupsList_FriendGroup {
    return CMsgClientFriendsGroupsList_FriendGroup.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientFriendsGroupsList_FriendGroup>, I>>(
    object: I,
  ): CMsgClientFriendsGroupsList_FriendGroup {
    const message = createBaseCMsgClientFriendsGroupsList_FriendGroup();
    message.nGroupID = object.nGroupID ?? 0;
    message.strGroupName = object.strGroupName ?? "";
    return message;
  },
};

function createBaseCMsgClientFriendsGroupsList_FriendGroupsMembership(): CMsgClientFriendsGroupsList_FriendGroupsMembership {
  return { ulSteamID: 0, nGroupID: 0 };
}

export const CMsgClientFriendsGroupsList_FriendGroupsMembership = {
  encode(
    message: CMsgClientFriendsGroupsList_FriendGroupsMembership,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.ulSteamID !== 0) {
      writer.uint32(9).fixed64(message.ulSteamID);
    }
    if (message.nGroupID !== 0) {
      writer.uint32(16).int32(message.nGroupID);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientFriendsGroupsList_FriendGroupsMembership {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientFriendsGroupsList_FriendGroupsMembership();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.ulSteamID = longToNumber(reader.fixed64() as Long);
          break;
        case 2:
          message.nGroupID = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgClientFriendsGroupsList_FriendGroupsMembership {
    return {
      ulSteamID: isSet(object.ulSteamID) ? Number(object.ulSteamID) : 0,
      nGroupID: isSet(object.nGroupID) ? Number(object.nGroupID) : 0,
    };
  },

  toJSON(message: CMsgClientFriendsGroupsList_FriendGroupsMembership): unknown {
    const obj: any = {};
    message.ulSteamID !== undefined && (obj.ulSteamID = Math.round(message.ulSteamID));
    message.nGroupID !== undefined && (obj.nGroupID = Math.round(message.nGroupID));
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientFriendsGroupsList_FriendGroupsMembership>, I>>(
    base?: I,
  ): CMsgClientFriendsGroupsList_FriendGroupsMembership {
    return CMsgClientFriendsGroupsList_FriendGroupsMembership.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientFriendsGroupsList_FriendGroupsMembership>, I>>(
    object: I,
  ): CMsgClientFriendsGroupsList_FriendGroupsMembership {
    const message = createBaseCMsgClientFriendsGroupsList_FriendGroupsMembership();
    message.ulSteamID = object.ulSteamID ?? 0;
    message.nGroupID = object.nGroupID ?? 0;
    return message;
  },
};

function createBaseCMsgClientPlayerNicknameList(): CMsgClientPlayerNicknameList {
  return { removal: false, incremental: false, nicknames: [] };
}

export const CMsgClientPlayerNicknameList = {
  encode(message: CMsgClientPlayerNicknameList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.removal === true) {
      writer.uint32(8).bool(message.removal);
    }
    if (message.incremental === true) {
      writer.uint32(16).bool(message.incremental);
    }
    for (const v of message.nicknames) {
      CMsgClientPlayerNicknameList_PlayerNickname.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientPlayerNicknameList {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientPlayerNicknameList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.removal = reader.bool();
          break;
        case 2:
          message.incremental = reader.bool();
          break;
        case 3:
          message.nicknames.push(CMsgClientPlayerNicknameList_PlayerNickname.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgClientPlayerNicknameList {
    return {
      removal: isSet(object.removal) ? Boolean(object.removal) : false,
      incremental: isSet(object.incremental) ? Boolean(object.incremental) : false,
      nicknames: Array.isArray(object?.nicknames)
        ? object.nicknames.map((e: any) => CMsgClientPlayerNicknameList_PlayerNickname.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgClientPlayerNicknameList): unknown {
    const obj: any = {};
    message.removal !== undefined && (obj.removal = message.removal);
    message.incremental !== undefined && (obj.incremental = message.incremental);
    if (message.nicknames) {
      obj.nicknames = message.nicknames.map((e) =>
        e ? CMsgClientPlayerNicknameList_PlayerNickname.toJSON(e) : undefined
      );
    } else {
      obj.nicknames = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientPlayerNicknameList>, I>>(base?: I): CMsgClientPlayerNicknameList {
    return CMsgClientPlayerNicknameList.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientPlayerNicknameList>, I>>(object: I): CMsgClientPlayerNicknameList {
    const message = createBaseCMsgClientPlayerNicknameList();
    message.removal = object.removal ?? false;
    message.incremental = object.incremental ?? false;
    message.nicknames = object.nicknames?.map((e) => CMsgClientPlayerNicknameList_PlayerNickname.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgClientPlayerNicknameList_PlayerNickname(): CMsgClientPlayerNicknameList_PlayerNickname {
  return { steamid: 0, nickname: "" };
}

export const CMsgClientPlayerNicknameList_PlayerNickname = {
  encode(message: CMsgClientPlayerNicknameList_PlayerNickname, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.steamid !== 0) {
      writer.uint32(9).fixed64(message.steamid);
    }
    if (message.nickname !== "") {
      writer.uint32(26).string(message.nickname);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientPlayerNicknameList_PlayerNickname {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientPlayerNicknameList_PlayerNickname();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.steamid = longToNumber(reader.fixed64() as Long);
          break;
        case 3:
          message.nickname = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgClientPlayerNicknameList_PlayerNickname {
    return {
      steamid: isSet(object.steamid) ? Number(object.steamid) : 0,
      nickname: isSet(object.nickname) ? String(object.nickname) : "",
    };
  },

  toJSON(message: CMsgClientPlayerNicknameList_PlayerNickname): unknown {
    const obj: any = {};
    message.steamid !== undefined && (obj.steamid = Math.round(message.steamid));
    message.nickname !== undefined && (obj.nickname = message.nickname);
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientPlayerNicknameList_PlayerNickname>, I>>(
    base?: I,
  ): CMsgClientPlayerNicknameList_PlayerNickname {
    return CMsgClientPlayerNicknameList_PlayerNickname.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientPlayerNicknameList_PlayerNickname>, I>>(
    object: I,
  ): CMsgClientPlayerNicknameList_PlayerNickname {
    const message = createBaseCMsgClientPlayerNicknameList_PlayerNickname();
    message.steamid = object.steamid ?? 0;
    message.nickname = object.nickname ?? "";
    return message;
  },
};

function createBaseCMsgClientSetPlayerNickname(): CMsgClientSetPlayerNickname {
  return { steamid: 0, nickname: "" };
}

export const CMsgClientSetPlayerNickname = {
  encode(message: CMsgClientSetPlayerNickname, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.steamid !== 0) {
      writer.uint32(9).fixed64(message.steamid);
    }
    if (message.nickname !== "") {
      writer.uint32(18).string(message.nickname);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientSetPlayerNickname {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientSetPlayerNickname();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.steamid = longToNumber(reader.fixed64() as Long);
          break;
        case 2:
          message.nickname = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgClientSetPlayerNickname {
    return {
      steamid: isSet(object.steamid) ? Number(object.steamid) : 0,
      nickname: isSet(object.nickname) ? String(object.nickname) : "",
    };
  },

  toJSON(message: CMsgClientSetPlayerNickname): unknown {
    const obj: any = {};
    message.steamid !== undefined && (obj.steamid = Math.round(message.steamid));
    message.nickname !== undefined && (obj.nickname = message.nickname);
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientSetPlayerNickname>, I>>(base?: I): CMsgClientSetPlayerNickname {
    return CMsgClientSetPlayerNickname.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientSetPlayerNickname>, I>>(object: I): CMsgClientSetPlayerNickname {
    const message = createBaseCMsgClientSetPlayerNickname();
    message.steamid = object.steamid ?? 0;
    message.nickname = object.nickname ?? "";
    return message;
  },
};

function createBaseCMsgClientSetPlayerNicknameResponse(): CMsgClientSetPlayerNicknameResponse {
  return { eresult: 0 };
}

export const CMsgClientSetPlayerNicknameResponse = {
  encode(message: CMsgClientSetPlayerNicknameResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eresult !== 0) {
      writer.uint32(8).uint32(message.eresult);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientSetPlayerNicknameResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientSetPlayerNicknameResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.eresult = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgClientSetPlayerNicknameResponse {
    return { eresult: isSet(object.eresult) ? Number(object.eresult) : 0 };
  },

  toJSON(message: CMsgClientSetPlayerNicknameResponse): unknown {
    const obj: any = {};
    message.eresult !== undefined && (obj.eresult = Math.round(message.eresult));
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientSetPlayerNicknameResponse>, I>>(
    base?: I,
  ): CMsgClientSetPlayerNicknameResponse {
    return CMsgClientSetPlayerNicknameResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientSetPlayerNicknameResponse>, I>>(
    object: I,
  ): CMsgClientSetPlayerNicknameResponse {
    const message = createBaseCMsgClientSetPlayerNicknameResponse();
    message.eresult = object.eresult ?? 0;
    return message;
  },
};

function createBaseCMsgClientRequestFriendData(): CMsgClientRequestFriendData {
  return { personaStateRequested: 0, friends: [] };
}

export const CMsgClientRequestFriendData = {
  encode(message: CMsgClientRequestFriendData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.personaStateRequested !== 0) {
      writer.uint32(8).uint32(message.personaStateRequested);
    }
    writer.uint32(18).fork();
    for (const v of message.friends) {
      writer.fixed64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientRequestFriendData {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientRequestFriendData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.personaStateRequested = reader.uint32();
          break;
        case 2:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.friends.push(longToNumber(reader.fixed64() as Long));
            }
          } else {
            message.friends.push(longToNumber(reader.fixed64() as Long));
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgClientRequestFriendData {
    return {
      personaStateRequested: isSet(object.personaStateRequested) ? Number(object.personaStateRequested) : 0,
      friends: Array.isArray(object?.friends) ? object.friends.map((e: any) => Number(e)) : [],
    };
  },

  toJSON(message: CMsgClientRequestFriendData): unknown {
    const obj: any = {};
    message.personaStateRequested !== undefined &&
      (obj.personaStateRequested = Math.round(message.personaStateRequested));
    if (message.friends) {
      obj.friends = message.friends.map((e) => Math.round(e));
    } else {
      obj.friends = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientRequestFriendData>, I>>(base?: I): CMsgClientRequestFriendData {
    return CMsgClientRequestFriendData.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientRequestFriendData>, I>>(object: I): CMsgClientRequestFriendData {
    const message = createBaseCMsgClientRequestFriendData();
    message.personaStateRequested = object.personaStateRequested ?? 0;
    message.friends = object.friends?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgClientChangeStatus(): CMsgClientChangeStatus {
  return {
    personaState: 0,
    playerName: "",
    isAutoGeneratedName: false,
    highPriority: false,
    personaSetByUser: false,
    personaStateFlags: 0,
    needPersonaResponse: false,
    isClientIdle: false,
  };
}

export const CMsgClientChangeStatus = {
  encode(message: CMsgClientChangeStatus, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.personaState !== 0) {
      writer.uint32(8).uint32(message.personaState);
    }
    if (message.playerName !== "") {
      writer.uint32(18).string(message.playerName);
    }
    if (message.isAutoGeneratedName === true) {
      writer.uint32(24).bool(message.isAutoGeneratedName);
    }
    if (message.highPriority === true) {
      writer.uint32(32).bool(message.highPriority);
    }
    if (message.personaSetByUser === true) {
      writer.uint32(40).bool(message.personaSetByUser);
    }
    if (message.personaStateFlags !== 0) {
      writer.uint32(48).uint32(message.personaStateFlags);
    }
    if (message.needPersonaResponse === true) {
      writer.uint32(56).bool(message.needPersonaResponse);
    }
    if (message.isClientIdle === true) {
      writer.uint32(64).bool(message.isClientIdle);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientChangeStatus {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientChangeStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.personaState = reader.uint32();
          break;
        case 2:
          message.playerName = reader.string();
          break;
        case 3:
          message.isAutoGeneratedName = reader.bool();
          break;
        case 4:
          message.highPriority = reader.bool();
          break;
        case 5:
          message.personaSetByUser = reader.bool();
          break;
        case 6:
          message.personaStateFlags = reader.uint32();
          break;
        case 7:
          message.needPersonaResponse = reader.bool();
          break;
        case 8:
          message.isClientIdle = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgClientChangeStatus {
    return {
      personaState: isSet(object.personaState) ? Number(object.personaState) : 0,
      playerName: isSet(object.playerName) ? String(object.playerName) : "",
      isAutoGeneratedName: isSet(object.isAutoGeneratedName) ? Boolean(object.isAutoGeneratedName) : false,
      highPriority: isSet(object.highPriority) ? Boolean(object.highPriority) : false,
      personaSetByUser: isSet(object.personaSetByUser) ? Boolean(object.personaSetByUser) : false,
      personaStateFlags: isSet(object.personaStateFlags) ? Number(object.personaStateFlags) : 0,
      needPersonaResponse: isSet(object.needPersonaResponse) ? Boolean(object.needPersonaResponse) : false,
      isClientIdle: isSet(object.isClientIdle) ? Boolean(object.isClientIdle) : false,
    };
  },

  toJSON(message: CMsgClientChangeStatus): unknown {
    const obj: any = {};
    message.personaState !== undefined && (obj.personaState = Math.round(message.personaState));
    message.playerName !== undefined && (obj.playerName = message.playerName);
    message.isAutoGeneratedName !== undefined && (obj.isAutoGeneratedName = message.isAutoGeneratedName);
    message.highPriority !== undefined && (obj.highPriority = message.highPriority);
    message.personaSetByUser !== undefined && (obj.personaSetByUser = message.personaSetByUser);
    message.personaStateFlags !== undefined && (obj.personaStateFlags = Math.round(message.personaStateFlags));
    message.needPersonaResponse !== undefined && (obj.needPersonaResponse = message.needPersonaResponse);
    message.isClientIdle !== undefined && (obj.isClientIdle = message.isClientIdle);
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientChangeStatus>, I>>(base?: I): CMsgClientChangeStatus {
    return CMsgClientChangeStatus.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientChangeStatus>, I>>(object: I): CMsgClientChangeStatus {
    const message = createBaseCMsgClientChangeStatus();
    message.personaState = object.personaState ?? 0;
    message.playerName = object.playerName ?? "";
    message.isAutoGeneratedName = object.isAutoGeneratedName ?? false;
    message.highPriority = object.highPriority ?? false;
    message.personaSetByUser = object.personaSetByUser ?? false;
    message.personaStateFlags = object.personaStateFlags ?? 0;
    message.needPersonaResponse = object.needPersonaResponse ?? false;
    message.isClientIdle = object.isClientIdle ?? false;
    return message;
  },
};

function createBaseCMsgPersonaChangeResponse(): CMsgPersonaChangeResponse {
  return { result: 0, playerName: "" };
}

export const CMsgPersonaChangeResponse = {
  encode(message: CMsgPersonaChangeResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).uint32(message.result);
    }
    if (message.playerName !== "") {
      writer.uint32(18).string(message.playerName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgPersonaChangeResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgPersonaChangeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.result = reader.uint32();
          break;
        case 2:
          message.playerName = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgPersonaChangeResponse {
    return {
      result: isSet(object.result) ? Number(object.result) : 0,
      playerName: isSet(object.playerName) ? String(object.playerName) : "",
    };
  },

  toJSON(message: CMsgPersonaChangeResponse): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = Math.round(message.result));
    message.playerName !== undefined && (obj.playerName = message.playerName);
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgPersonaChangeResponse>, I>>(base?: I): CMsgPersonaChangeResponse {
    return CMsgPersonaChangeResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgPersonaChangeResponse>, I>>(object: I): CMsgPersonaChangeResponse {
    const message = createBaseCMsgPersonaChangeResponse();
    message.result = object.result ?? 0;
    message.playerName = object.playerName ?? "";
    return message;
  },
};

function createBaseCMsgClientPersonaState(): CMsgClientPersonaState {
  return { statusFlags: 0, friends: [] };
}

export const CMsgClientPersonaState = {
  encode(message: CMsgClientPersonaState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.statusFlags !== 0) {
      writer.uint32(8).uint32(message.statusFlags);
    }
    for (const v of message.friends) {
      CMsgClientPersonaState_Friend.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientPersonaState {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientPersonaState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.statusFlags = reader.uint32();
          break;
        case 2:
          message.friends.push(CMsgClientPersonaState_Friend.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgClientPersonaState {
    return {
      statusFlags: isSet(object.statusFlags) ? Number(object.statusFlags) : 0,
      friends: Array.isArray(object?.friends)
        ? object.friends.map((e: any) => CMsgClientPersonaState_Friend.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgClientPersonaState): unknown {
    const obj: any = {};
    message.statusFlags !== undefined && (obj.statusFlags = Math.round(message.statusFlags));
    if (message.friends) {
      obj.friends = message.friends.map((e) => e ? CMsgClientPersonaState_Friend.toJSON(e) : undefined);
    } else {
      obj.friends = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientPersonaState>, I>>(base?: I): CMsgClientPersonaState {
    return CMsgClientPersonaState.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientPersonaState>, I>>(object: I): CMsgClientPersonaState {
    const message = createBaseCMsgClientPersonaState();
    message.statusFlags = object.statusFlags ?? 0;
    message.friends = object.friends?.map((e) => CMsgClientPersonaState_Friend.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgClientPersonaState_Friend(): CMsgClientPersonaState_Friend {
  return {
    friendid: 0,
    personaState: 0,
    gamePlayedAppId: 0,
    gameServerIp: 0,
    gameServerPort: 0,
    personaStateFlags: 0,
    onlineSessionInstances: 0,
    personaSetByUser: false,
    playerName: "",
    queryPort: 0,
    steamidSource: 0,
    avatarHash: Buffer.alloc(0),
    lastLogoff: 0,
    lastLogon: 0,
    lastSeenOnline: 0,
    clanRank: 0,
    gameName: "",
    gameid: 0,
    gameDataBlob: Buffer.alloc(0),
    clanData: undefined,
    clanTag: "",
    richPresence: [],
    broadcastId: 0,
    gameLobbyId: 0,
    watchingBroadcastAccountid: 0,
    watchingBroadcastAppid: 0,
    watchingBroadcastViewers: 0,
    watchingBroadcastTitle: "",
    isCommunityBanned: false,
    playerNamePendingReview: false,
    avatarPendingReview: false,
  };
}

export const CMsgClientPersonaState_Friend = {
  encode(message: CMsgClientPersonaState_Friend, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.friendid !== 0) {
      writer.uint32(9).fixed64(message.friendid);
    }
    if (message.personaState !== 0) {
      writer.uint32(16).uint32(message.personaState);
    }
    if (message.gamePlayedAppId !== 0) {
      writer.uint32(24).uint32(message.gamePlayedAppId);
    }
    if (message.gameServerIp !== 0) {
      writer.uint32(32).uint32(message.gameServerIp);
    }
    if (message.gameServerPort !== 0) {
      writer.uint32(40).uint32(message.gameServerPort);
    }
    if (message.personaStateFlags !== 0) {
      writer.uint32(48).uint32(message.personaStateFlags);
    }
    if (message.onlineSessionInstances !== 0) {
      writer.uint32(56).uint32(message.onlineSessionInstances);
    }
    if (message.personaSetByUser === true) {
      writer.uint32(80).bool(message.personaSetByUser);
    }
    if (message.playerName !== "") {
      writer.uint32(122).string(message.playerName);
    }
    if (message.queryPort !== 0) {
      writer.uint32(160).uint32(message.queryPort);
    }
    if (message.steamidSource !== 0) {
      writer.uint32(201).fixed64(message.steamidSource);
    }
    if (message.avatarHash.length !== 0) {
      writer.uint32(250).bytes(message.avatarHash);
    }
    if (message.lastLogoff !== 0) {
      writer.uint32(360).uint32(message.lastLogoff);
    }
    if (message.lastLogon !== 0) {
      writer.uint32(368).uint32(message.lastLogon);
    }
    if (message.lastSeenOnline !== 0) {
      writer.uint32(376).uint32(message.lastSeenOnline);
    }
    if (message.clanRank !== 0) {
      writer.uint32(400).uint32(message.clanRank);
    }
    if (message.gameName !== "") {
      writer.uint32(442).string(message.gameName);
    }
    if (message.gameid !== 0) {
      writer.uint32(449).fixed64(message.gameid);
    }
    if (message.gameDataBlob.length !== 0) {
      writer.uint32(482).bytes(message.gameDataBlob);
    }
    if (message.clanData !== undefined) {
      CMsgClientPersonaState_Friend_ClanData.encode(message.clanData, writer.uint32(514).fork()).ldelim();
    }
    if (message.clanTag !== "") {
      writer.uint32(522).string(message.clanTag);
    }
    for (const v of message.richPresence) {
      CMsgClientPersonaState_Friend_KV.encode(v!, writer.uint32(570).fork()).ldelim();
    }
    if (message.broadcastId !== 0) {
      writer.uint32(577).fixed64(message.broadcastId);
    }
    if (message.gameLobbyId !== 0) {
      writer.uint32(585).fixed64(message.gameLobbyId);
    }
    if (message.watchingBroadcastAccountid !== 0) {
      writer.uint32(592).uint32(message.watchingBroadcastAccountid);
    }
    if (message.watchingBroadcastAppid !== 0) {
      writer.uint32(600).uint32(message.watchingBroadcastAppid);
    }
    if (message.watchingBroadcastViewers !== 0) {
      writer.uint32(608).uint32(message.watchingBroadcastViewers);
    }
    if (message.watchingBroadcastTitle !== "") {
      writer.uint32(618).string(message.watchingBroadcastTitle);
    }
    if (message.isCommunityBanned === true) {
      writer.uint32(624).bool(message.isCommunityBanned);
    }
    if (message.playerNamePendingReview === true) {
      writer.uint32(632).bool(message.playerNamePendingReview);
    }
    if (message.avatarPendingReview === true) {
      writer.uint32(640).bool(message.avatarPendingReview);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientPersonaState_Friend {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientPersonaState_Friend();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.friendid = longToNumber(reader.fixed64() as Long);
          break;
        case 2:
          message.personaState = reader.uint32();
          break;
        case 3:
          message.gamePlayedAppId = reader.uint32();
          break;
        case 4:
          message.gameServerIp = reader.uint32();
          break;
        case 5:
          message.gameServerPort = reader.uint32();
          break;
        case 6:
          message.personaStateFlags = reader.uint32();
          break;
        case 7:
          message.onlineSessionInstances = reader.uint32();
          break;
        case 10:
          message.personaSetByUser = reader.bool();
          break;
        case 15:
          message.playerName = reader.string();
          break;
        case 20:
          message.queryPort = reader.uint32();
          break;
        case 25:
          message.steamidSource = longToNumber(reader.fixed64() as Long);
          break;
        case 31:
          message.avatarHash = reader.bytes() as Buffer;
          break;
        case 45:
          message.lastLogoff = reader.uint32();
          break;
        case 46:
          message.lastLogon = reader.uint32();
          break;
        case 47:
          message.lastSeenOnline = reader.uint32();
          break;
        case 50:
          message.clanRank = reader.uint32();
          break;
        case 55:
          message.gameName = reader.string();
          break;
        case 56:
          message.gameid = longToNumber(reader.fixed64() as Long);
          break;
        case 60:
          message.gameDataBlob = reader.bytes() as Buffer;
          break;
        case 64:
          message.clanData = CMsgClientPersonaState_Friend_ClanData.decode(reader, reader.uint32());
          break;
        case 65:
          message.clanTag = reader.string();
          break;
        case 71:
          message.richPresence.push(CMsgClientPersonaState_Friend_KV.decode(reader, reader.uint32()));
          break;
        case 72:
          message.broadcastId = longToNumber(reader.fixed64() as Long);
          break;
        case 73:
          message.gameLobbyId = longToNumber(reader.fixed64() as Long);
          break;
        case 74:
          message.watchingBroadcastAccountid = reader.uint32();
          break;
        case 75:
          message.watchingBroadcastAppid = reader.uint32();
          break;
        case 76:
          message.watchingBroadcastViewers = reader.uint32();
          break;
        case 77:
          message.watchingBroadcastTitle = reader.string();
          break;
        case 78:
          message.isCommunityBanned = reader.bool();
          break;
        case 79:
          message.playerNamePendingReview = reader.bool();
          break;
        case 80:
          message.avatarPendingReview = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgClientPersonaState_Friend {
    return {
      friendid: isSet(object.friendid) ? Number(object.friendid) : 0,
      personaState: isSet(object.personaState) ? Number(object.personaState) : 0,
      gamePlayedAppId: isSet(object.gamePlayedAppId) ? Number(object.gamePlayedAppId) : 0,
      gameServerIp: isSet(object.gameServerIp) ? Number(object.gameServerIp) : 0,
      gameServerPort: isSet(object.gameServerPort) ? Number(object.gameServerPort) : 0,
      personaStateFlags: isSet(object.personaStateFlags) ? Number(object.personaStateFlags) : 0,
      onlineSessionInstances: isSet(object.onlineSessionInstances) ? Number(object.onlineSessionInstances) : 0,
      personaSetByUser: isSet(object.personaSetByUser) ? Boolean(object.personaSetByUser) : false,
      playerName: isSet(object.playerName) ? String(object.playerName) : "",
      queryPort: isSet(object.queryPort) ? Number(object.queryPort) : 0,
      steamidSource: isSet(object.steamidSource) ? Number(object.steamidSource) : 0,
      avatarHash: isSet(object.avatarHash) ? Buffer.from(bytesFromBase64(object.avatarHash)) : Buffer.alloc(0),
      lastLogoff: isSet(object.lastLogoff) ? Number(object.lastLogoff) : 0,
      lastLogon: isSet(object.lastLogon) ? Number(object.lastLogon) : 0,
      lastSeenOnline: isSet(object.lastSeenOnline) ? Number(object.lastSeenOnline) : 0,
      clanRank: isSet(object.clanRank) ? Number(object.clanRank) : 0,
      gameName: isSet(object.gameName) ? String(object.gameName) : "",
      gameid: isSet(object.gameid) ? Number(object.gameid) : 0,
      gameDataBlob: isSet(object.gameDataBlob) ? Buffer.from(bytesFromBase64(object.gameDataBlob)) : Buffer.alloc(0),
      clanData: isSet(object.clanData) ? CMsgClientPersonaState_Friend_ClanData.fromJSON(object.clanData) : undefined,
      clanTag: isSet(object.clanTag) ? String(object.clanTag) : "",
      richPresence: Array.isArray(object?.richPresence)
        ? object.richPresence.map((e: any) => CMsgClientPersonaState_Friend_KV.fromJSON(e))
        : [],
      broadcastId: isSet(object.broadcastId) ? Number(object.broadcastId) : 0,
      gameLobbyId: isSet(object.gameLobbyId) ? Number(object.gameLobbyId) : 0,
      watchingBroadcastAccountid: isSet(object.watchingBroadcastAccountid)
        ? Number(object.watchingBroadcastAccountid)
        : 0,
      watchingBroadcastAppid: isSet(object.watchingBroadcastAppid) ? Number(object.watchingBroadcastAppid) : 0,
      watchingBroadcastViewers: isSet(object.watchingBroadcastViewers) ? Number(object.watchingBroadcastViewers) : 0,
      watchingBroadcastTitle: isSet(object.watchingBroadcastTitle) ? String(object.watchingBroadcastTitle) : "",
      isCommunityBanned: isSet(object.isCommunityBanned) ? Boolean(object.isCommunityBanned) : false,
      playerNamePendingReview: isSet(object.playerNamePendingReview) ? Boolean(object.playerNamePendingReview) : false,
      avatarPendingReview: isSet(object.avatarPendingReview) ? Boolean(object.avatarPendingReview) : false,
    };
  },

  toJSON(message: CMsgClientPersonaState_Friend): unknown {
    const obj: any = {};
    message.friendid !== undefined && (obj.friendid = Math.round(message.friendid));
    message.personaState !== undefined && (obj.personaState = Math.round(message.personaState));
    message.gamePlayedAppId !== undefined && (obj.gamePlayedAppId = Math.round(message.gamePlayedAppId));
    message.gameServerIp !== undefined && (obj.gameServerIp = Math.round(message.gameServerIp));
    message.gameServerPort !== undefined && (obj.gameServerPort = Math.round(message.gameServerPort));
    message.personaStateFlags !== undefined && (obj.personaStateFlags = Math.round(message.personaStateFlags));
    message.onlineSessionInstances !== undefined &&
      (obj.onlineSessionInstances = Math.round(message.onlineSessionInstances));
    message.personaSetByUser !== undefined && (obj.personaSetByUser = message.personaSetByUser);
    message.playerName !== undefined && (obj.playerName = message.playerName);
    message.queryPort !== undefined && (obj.queryPort = Math.round(message.queryPort));
    message.steamidSource !== undefined && (obj.steamidSource = Math.round(message.steamidSource));
    message.avatarHash !== undefined &&
      (obj.avatarHash = base64FromBytes(message.avatarHash !== undefined ? message.avatarHash : Buffer.alloc(0)));
    message.lastLogoff !== undefined && (obj.lastLogoff = Math.round(message.lastLogoff));
    message.lastLogon !== undefined && (obj.lastLogon = Math.round(message.lastLogon));
    message.lastSeenOnline !== undefined && (obj.lastSeenOnline = Math.round(message.lastSeenOnline));
    message.clanRank !== undefined && (obj.clanRank = Math.round(message.clanRank));
    message.gameName !== undefined && (obj.gameName = message.gameName);
    message.gameid !== undefined && (obj.gameid = Math.round(message.gameid));
    message.gameDataBlob !== undefined &&
      (obj.gameDataBlob = base64FromBytes(message.gameDataBlob !== undefined ? message.gameDataBlob : Buffer.alloc(0)));
    message.clanData !== undefined &&
      (obj.clanData = message.clanData ? CMsgClientPersonaState_Friend_ClanData.toJSON(message.clanData) : undefined);
    message.clanTag !== undefined && (obj.clanTag = message.clanTag);
    if (message.richPresence) {
      obj.richPresence = message.richPresence.map((e) => e ? CMsgClientPersonaState_Friend_KV.toJSON(e) : undefined);
    } else {
      obj.richPresence = [];
    }
    message.broadcastId !== undefined && (obj.broadcastId = Math.round(message.broadcastId));
    message.gameLobbyId !== undefined && (obj.gameLobbyId = Math.round(message.gameLobbyId));
    message.watchingBroadcastAccountid !== undefined &&
      (obj.watchingBroadcastAccountid = Math.round(message.watchingBroadcastAccountid));
    message.watchingBroadcastAppid !== undefined &&
      (obj.watchingBroadcastAppid = Math.round(message.watchingBroadcastAppid));
    message.watchingBroadcastViewers !== undefined &&
      (obj.watchingBroadcastViewers = Math.round(message.watchingBroadcastViewers));
    message.watchingBroadcastTitle !== undefined && (obj.watchingBroadcastTitle = message.watchingBroadcastTitle);
    message.isCommunityBanned !== undefined && (obj.isCommunityBanned = message.isCommunityBanned);
    message.playerNamePendingReview !== undefined && (obj.playerNamePendingReview = message.playerNamePendingReview);
    message.avatarPendingReview !== undefined && (obj.avatarPendingReview = message.avatarPendingReview);
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientPersonaState_Friend>, I>>(base?: I): CMsgClientPersonaState_Friend {
    return CMsgClientPersonaState_Friend.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientPersonaState_Friend>, I>>(
    object: I,
  ): CMsgClientPersonaState_Friend {
    const message = createBaseCMsgClientPersonaState_Friend();
    message.friendid = object.friendid ?? 0;
    message.personaState = object.personaState ?? 0;
    message.gamePlayedAppId = object.gamePlayedAppId ?? 0;
    message.gameServerIp = object.gameServerIp ?? 0;
    message.gameServerPort = object.gameServerPort ?? 0;
    message.personaStateFlags = object.personaStateFlags ?? 0;
    message.onlineSessionInstances = object.onlineSessionInstances ?? 0;
    message.personaSetByUser = object.personaSetByUser ?? false;
    message.playerName = object.playerName ?? "";
    message.queryPort = object.queryPort ?? 0;
    message.steamidSource = object.steamidSource ?? 0;
    message.avatarHash = object.avatarHash ?? Buffer.alloc(0);
    message.lastLogoff = object.lastLogoff ?? 0;
    message.lastLogon = object.lastLogon ?? 0;
    message.lastSeenOnline = object.lastSeenOnline ?? 0;
    message.clanRank = object.clanRank ?? 0;
    message.gameName = object.gameName ?? "";
    message.gameid = object.gameid ?? 0;
    message.gameDataBlob = object.gameDataBlob ?? Buffer.alloc(0);
    message.clanData = (object.clanData !== undefined && object.clanData !== null)
      ? CMsgClientPersonaState_Friend_ClanData.fromPartial(object.clanData)
      : undefined;
    message.clanTag = object.clanTag ?? "";
    message.richPresence = object.richPresence?.map((e) => CMsgClientPersonaState_Friend_KV.fromPartial(e)) || [];
    message.broadcastId = object.broadcastId ?? 0;
    message.gameLobbyId = object.gameLobbyId ?? 0;
    message.watchingBroadcastAccountid = object.watchingBroadcastAccountid ?? 0;
    message.watchingBroadcastAppid = object.watchingBroadcastAppid ?? 0;
    message.watchingBroadcastViewers = object.watchingBroadcastViewers ?? 0;
    message.watchingBroadcastTitle = object.watchingBroadcastTitle ?? "";
    message.isCommunityBanned = object.isCommunityBanned ?? false;
    message.playerNamePendingReview = object.playerNamePendingReview ?? false;
    message.avatarPendingReview = object.avatarPendingReview ?? false;
    return message;
  },
};

function createBaseCMsgClientPersonaState_Friend_ClanData(): CMsgClientPersonaState_Friend_ClanData {
  return { oggAppId: 0, chatGroupId: 0 };
}

export const CMsgClientPersonaState_Friend_ClanData = {
  encode(message: CMsgClientPersonaState_Friend_ClanData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.oggAppId !== 0) {
      writer.uint32(8).uint32(message.oggAppId);
    }
    if (message.chatGroupId !== 0) {
      writer.uint32(16).uint64(message.chatGroupId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientPersonaState_Friend_ClanData {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientPersonaState_Friend_ClanData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.oggAppId = reader.uint32();
          break;
        case 2:
          message.chatGroupId = longToNumber(reader.uint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgClientPersonaState_Friend_ClanData {
    return {
      oggAppId: isSet(object.oggAppId) ? Number(object.oggAppId) : 0,
      chatGroupId: isSet(object.chatGroupId) ? Number(object.chatGroupId) : 0,
    };
  },

  toJSON(message: CMsgClientPersonaState_Friend_ClanData): unknown {
    const obj: any = {};
    message.oggAppId !== undefined && (obj.oggAppId = Math.round(message.oggAppId));
    message.chatGroupId !== undefined && (obj.chatGroupId = Math.round(message.chatGroupId));
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientPersonaState_Friend_ClanData>, I>>(
    base?: I,
  ): CMsgClientPersonaState_Friend_ClanData {
    return CMsgClientPersonaState_Friend_ClanData.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientPersonaState_Friend_ClanData>, I>>(
    object: I,
  ): CMsgClientPersonaState_Friend_ClanData {
    const message = createBaseCMsgClientPersonaState_Friend_ClanData();
    message.oggAppId = object.oggAppId ?? 0;
    message.chatGroupId = object.chatGroupId ?? 0;
    return message;
  },
};

function createBaseCMsgClientPersonaState_Friend_KV(): CMsgClientPersonaState_Friend_KV {
  return { key: "", value: "" };
}

export const CMsgClientPersonaState_Friend_KV = {
  encode(message: CMsgClientPersonaState_Friend_KV, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientPersonaState_Friend_KV {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientPersonaState_Friend_KV();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgClientPersonaState_Friend_KV {
    return { key: isSet(object.key) ? String(object.key) : "", value: isSet(object.value) ? String(object.value) : "" };
  },

  toJSON(message: CMsgClientPersonaState_Friend_KV): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value);
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientPersonaState_Friend_KV>, I>>(
    base?: I,
  ): CMsgClientPersonaState_Friend_KV {
    return CMsgClientPersonaState_Friend_KV.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientPersonaState_Friend_KV>, I>>(
    object: I,
  ): CMsgClientPersonaState_Friend_KV {
    const message = createBaseCMsgClientPersonaState_Friend_KV();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCMsgClientFriendProfileInfo(): CMsgClientFriendProfileInfo {
  return { steamidFriend: 0 };
}

export const CMsgClientFriendProfileInfo = {
  encode(message: CMsgClientFriendProfileInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.steamidFriend !== 0) {
      writer.uint32(9).fixed64(message.steamidFriend);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientFriendProfileInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientFriendProfileInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.steamidFriend = longToNumber(reader.fixed64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgClientFriendProfileInfo {
    return { steamidFriend: isSet(object.steamidFriend) ? Number(object.steamidFriend) : 0 };
  },

  toJSON(message: CMsgClientFriendProfileInfo): unknown {
    const obj: any = {};
    message.steamidFriend !== undefined && (obj.steamidFriend = Math.round(message.steamidFriend));
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientFriendProfileInfo>, I>>(base?: I): CMsgClientFriendProfileInfo {
    return CMsgClientFriendProfileInfo.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientFriendProfileInfo>, I>>(object: I): CMsgClientFriendProfileInfo {
    const message = createBaseCMsgClientFriendProfileInfo();
    message.steamidFriend = object.steamidFriend ?? 0;
    return message;
  },
};

function createBaseCMsgClientFriendProfileInfoResponse(): CMsgClientFriendProfileInfoResponse {
  return {
    eresult: 0,
    steamidFriend: 0,
    timeCreated: 0,
    realName: "",
    cityName: "",
    stateName: "",
    countryName: "",
    headline: "",
    summary: "",
  };
}

export const CMsgClientFriendProfileInfoResponse = {
  encode(message: CMsgClientFriendProfileInfoResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eresult !== 0) {
      writer.uint32(8).int32(message.eresult);
    }
    if (message.steamidFriend !== 0) {
      writer.uint32(17).fixed64(message.steamidFriend);
    }
    if (message.timeCreated !== 0) {
      writer.uint32(24).uint32(message.timeCreated);
    }
    if (message.realName !== "") {
      writer.uint32(34).string(message.realName);
    }
    if (message.cityName !== "") {
      writer.uint32(42).string(message.cityName);
    }
    if (message.stateName !== "") {
      writer.uint32(50).string(message.stateName);
    }
    if (message.countryName !== "") {
      writer.uint32(58).string(message.countryName);
    }
    if (message.headline !== "") {
      writer.uint32(66).string(message.headline);
    }
    if (message.summary !== "") {
      writer.uint32(74).string(message.summary);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientFriendProfileInfoResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientFriendProfileInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.eresult = reader.int32();
          break;
        case 2:
          message.steamidFriend = longToNumber(reader.fixed64() as Long);
          break;
        case 3:
          message.timeCreated = reader.uint32();
          break;
        case 4:
          message.realName = reader.string();
          break;
        case 5:
          message.cityName = reader.string();
          break;
        case 6:
          message.stateName = reader.string();
          break;
        case 7:
          message.countryName = reader.string();
          break;
        case 8:
          message.headline = reader.string();
          break;
        case 9:
          message.summary = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgClientFriendProfileInfoResponse {
    return {
      eresult: isSet(object.eresult) ? Number(object.eresult) : 0,
      steamidFriend: isSet(object.steamidFriend) ? Number(object.steamidFriend) : 0,
      timeCreated: isSet(object.timeCreated) ? Number(object.timeCreated) : 0,
      realName: isSet(object.realName) ? String(object.realName) : "",
      cityName: isSet(object.cityName) ? String(object.cityName) : "",
      stateName: isSet(object.stateName) ? String(object.stateName) : "",
      countryName: isSet(object.countryName) ? String(object.countryName) : "",
      headline: isSet(object.headline) ? String(object.headline) : "",
      summary: isSet(object.summary) ? String(object.summary) : "",
    };
  },

  toJSON(message: CMsgClientFriendProfileInfoResponse): unknown {
    const obj: any = {};
    message.eresult !== undefined && (obj.eresult = Math.round(message.eresult));
    message.steamidFriend !== undefined && (obj.steamidFriend = Math.round(message.steamidFriend));
    message.timeCreated !== undefined && (obj.timeCreated = Math.round(message.timeCreated));
    message.realName !== undefined && (obj.realName = message.realName);
    message.cityName !== undefined && (obj.cityName = message.cityName);
    message.stateName !== undefined && (obj.stateName = message.stateName);
    message.countryName !== undefined && (obj.countryName = message.countryName);
    message.headline !== undefined && (obj.headline = message.headline);
    message.summary !== undefined && (obj.summary = message.summary);
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientFriendProfileInfoResponse>, I>>(
    base?: I,
  ): CMsgClientFriendProfileInfoResponse {
    return CMsgClientFriendProfileInfoResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientFriendProfileInfoResponse>, I>>(
    object: I,
  ): CMsgClientFriendProfileInfoResponse {
    const message = createBaseCMsgClientFriendProfileInfoResponse();
    message.eresult = object.eresult ?? 0;
    message.steamidFriend = object.steamidFriend ?? 0;
    message.timeCreated = object.timeCreated ?? 0;
    message.realName = object.realName ?? "";
    message.cityName = object.cityName ?? "";
    message.stateName = object.stateName ?? "";
    message.countryName = object.countryName ?? "";
    message.headline = object.headline ?? "";
    message.summary = object.summary ?? "";
    return message;
  },
};

function createBaseCMsgClientCreateFriendsGroup(): CMsgClientCreateFriendsGroup {
  return { steamid: 0, groupname: "", steamidFriends: [] };
}

export const CMsgClientCreateFriendsGroup = {
  encode(message: CMsgClientCreateFriendsGroup, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.steamid !== 0) {
      writer.uint32(9).fixed64(message.steamid);
    }
    if (message.groupname !== "") {
      writer.uint32(18).string(message.groupname);
    }
    writer.uint32(26).fork();
    for (const v of message.steamidFriends) {
      writer.fixed64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientCreateFriendsGroup {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientCreateFriendsGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.steamid = longToNumber(reader.fixed64() as Long);
          break;
        case 2:
          message.groupname = reader.string();
          break;
        case 3:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.steamidFriends.push(longToNumber(reader.fixed64() as Long));
            }
          } else {
            message.steamidFriends.push(longToNumber(reader.fixed64() as Long));
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgClientCreateFriendsGroup {
    return {
      steamid: isSet(object.steamid) ? Number(object.steamid) : 0,
      groupname: isSet(object.groupname) ? String(object.groupname) : "",
      steamidFriends: Array.isArray(object?.steamidFriends) ? object.steamidFriends.map((e: any) => Number(e)) : [],
    };
  },

  toJSON(message: CMsgClientCreateFriendsGroup): unknown {
    const obj: any = {};
    message.steamid !== undefined && (obj.steamid = Math.round(message.steamid));
    message.groupname !== undefined && (obj.groupname = message.groupname);
    if (message.steamidFriends) {
      obj.steamidFriends = message.steamidFriends.map((e) => Math.round(e));
    } else {
      obj.steamidFriends = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientCreateFriendsGroup>, I>>(base?: I): CMsgClientCreateFriendsGroup {
    return CMsgClientCreateFriendsGroup.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientCreateFriendsGroup>, I>>(object: I): CMsgClientCreateFriendsGroup {
    const message = createBaseCMsgClientCreateFriendsGroup();
    message.steamid = object.steamid ?? 0;
    message.groupname = object.groupname ?? "";
    message.steamidFriends = object.steamidFriends?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgClientCreateFriendsGroupResponse(): CMsgClientCreateFriendsGroupResponse {
  return { eresult: 0, groupid: 0 };
}

export const CMsgClientCreateFriendsGroupResponse = {
  encode(message: CMsgClientCreateFriendsGroupResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eresult !== 0) {
      writer.uint32(8).uint32(message.eresult);
    }
    if (message.groupid !== 0) {
      writer.uint32(16).int32(message.groupid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientCreateFriendsGroupResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientCreateFriendsGroupResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.eresult = reader.uint32();
          break;
        case 2:
          message.groupid = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgClientCreateFriendsGroupResponse {
    return {
      eresult: isSet(object.eresult) ? Number(object.eresult) : 0,
      groupid: isSet(object.groupid) ? Number(object.groupid) : 0,
    };
  },

  toJSON(message: CMsgClientCreateFriendsGroupResponse): unknown {
    const obj: any = {};
    message.eresult !== undefined && (obj.eresult = Math.round(message.eresult));
    message.groupid !== undefined && (obj.groupid = Math.round(message.groupid));
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientCreateFriendsGroupResponse>, I>>(
    base?: I,
  ): CMsgClientCreateFriendsGroupResponse {
    return CMsgClientCreateFriendsGroupResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientCreateFriendsGroupResponse>, I>>(
    object: I,
  ): CMsgClientCreateFriendsGroupResponse {
    const message = createBaseCMsgClientCreateFriendsGroupResponse();
    message.eresult = object.eresult ?? 0;
    message.groupid = object.groupid ?? 0;
    return message;
  },
};

function createBaseCMsgClientDeleteFriendsGroup(): CMsgClientDeleteFriendsGroup {
  return { steamid: 0, groupid: 0 };
}

export const CMsgClientDeleteFriendsGroup = {
  encode(message: CMsgClientDeleteFriendsGroup, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.steamid !== 0) {
      writer.uint32(9).fixed64(message.steamid);
    }
    if (message.groupid !== 0) {
      writer.uint32(16).int32(message.groupid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientDeleteFriendsGroup {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientDeleteFriendsGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.steamid = longToNumber(reader.fixed64() as Long);
          break;
        case 2:
          message.groupid = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgClientDeleteFriendsGroup {
    return {
      steamid: isSet(object.steamid) ? Number(object.steamid) : 0,
      groupid: isSet(object.groupid) ? Number(object.groupid) : 0,
    };
  },

  toJSON(message: CMsgClientDeleteFriendsGroup): unknown {
    const obj: any = {};
    message.steamid !== undefined && (obj.steamid = Math.round(message.steamid));
    message.groupid !== undefined && (obj.groupid = Math.round(message.groupid));
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientDeleteFriendsGroup>, I>>(base?: I): CMsgClientDeleteFriendsGroup {
    return CMsgClientDeleteFriendsGroup.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientDeleteFriendsGroup>, I>>(object: I): CMsgClientDeleteFriendsGroup {
    const message = createBaseCMsgClientDeleteFriendsGroup();
    message.steamid = object.steamid ?? 0;
    message.groupid = object.groupid ?? 0;
    return message;
  },
};

function createBaseCMsgClientDeleteFriendsGroupResponse(): CMsgClientDeleteFriendsGroupResponse {
  return { eresult: 0 };
}

export const CMsgClientDeleteFriendsGroupResponse = {
  encode(message: CMsgClientDeleteFriendsGroupResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eresult !== 0) {
      writer.uint32(8).uint32(message.eresult);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientDeleteFriendsGroupResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientDeleteFriendsGroupResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.eresult = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgClientDeleteFriendsGroupResponse {
    return { eresult: isSet(object.eresult) ? Number(object.eresult) : 0 };
  },

  toJSON(message: CMsgClientDeleteFriendsGroupResponse): unknown {
    const obj: any = {};
    message.eresult !== undefined && (obj.eresult = Math.round(message.eresult));
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientDeleteFriendsGroupResponse>, I>>(
    base?: I,
  ): CMsgClientDeleteFriendsGroupResponse {
    return CMsgClientDeleteFriendsGroupResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientDeleteFriendsGroupResponse>, I>>(
    object: I,
  ): CMsgClientDeleteFriendsGroupResponse {
    const message = createBaseCMsgClientDeleteFriendsGroupResponse();
    message.eresult = object.eresult ?? 0;
    return message;
  },
};

function createBaseCMsgClientManageFriendsGroup(): CMsgClientManageFriendsGroup {
  return { groupid: 0, groupname: "", steamidFriendsAdded: [], steamidFriendsRemoved: [] };
}

export const CMsgClientManageFriendsGroup = {
  encode(message: CMsgClientManageFriendsGroup, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.groupid !== 0) {
      writer.uint32(8).int32(message.groupid);
    }
    if (message.groupname !== "") {
      writer.uint32(18).string(message.groupname);
    }
    writer.uint32(26).fork();
    for (const v of message.steamidFriendsAdded) {
      writer.fixed64(v);
    }
    writer.ldelim();
    writer.uint32(34).fork();
    for (const v of message.steamidFriendsRemoved) {
      writer.fixed64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientManageFriendsGroup {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientManageFriendsGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.groupid = reader.int32();
          break;
        case 2:
          message.groupname = reader.string();
          break;
        case 3:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.steamidFriendsAdded.push(longToNumber(reader.fixed64() as Long));
            }
          } else {
            message.steamidFriendsAdded.push(longToNumber(reader.fixed64() as Long));
          }
          break;
        case 4:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.steamidFriendsRemoved.push(longToNumber(reader.fixed64() as Long));
            }
          } else {
            message.steamidFriendsRemoved.push(longToNumber(reader.fixed64() as Long));
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgClientManageFriendsGroup {
    return {
      groupid: isSet(object.groupid) ? Number(object.groupid) : 0,
      groupname: isSet(object.groupname) ? String(object.groupname) : "",
      steamidFriendsAdded: Array.isArray(object?.steamidFriendsAdded)
        ? object.steamidFriendsAdded.map((e: any) => Number(e))
        : [],
      steamidFriendsRemoved: Array.isArray(object?.steamidFriendsRemoved)
        ? object.steamidFriendsRemoved.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: CMsgClientManageFriendsGroup): unknown {
    const obj: any = {};
    message.groupid !== undefined && (obj.groupid = Math.round(message.groupid));
    message.groupname !== undefined && (obj.groupname = message.groupname);
    if (message.steamidFriendsAdded) {
      obj.steamidFriendsAdded = message.steamidFriendsAdded.map((e) => Math.round(e));
    } else {
      obj.steamidFriendsAdded = [];
    }
    if (message.steamidFriendsRemoved) {
      obj.steamidFriendsRemoved = message.steamidFriendsRemoved.map((e) => Math.round(e));
    } else {
      obj.steamidFriendsRemoved = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientManageFriendsGroup>, I>>(base?: I): CMsgClientManageFriendsGroup {
    return CMsgClientManageFriendsGroup.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientManageFriendsGroup>, I>>(object: I): CMsgClientManageFriendsGroup {
    const message = createBaseCMsgClientManageFriendsGroup();
    message.groupid = object.groupid ?? 0;
    message.groupname = object.groupname ?? "";
    message.steamidFriendsAdded = object.steamidFriendsAdded?.map((e) => e) || [];
    message.steamidFriendsRemoved = object.steamidFriendsRemoved?.map((e) => e) || [];
    return message;
  },
};

function createBaseCMsgClientManageFriendsGroupResponse(): CMsgClientManageFriendsGroupResponse {
  return { eresult: 0 };
}

export const CMsgClientManageFriendsGroupResponse = {
  encode(message: CMsgClientManageFriendsGroupResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eresult !== 0) {
      writer.uint32(8).uint32(message.eresult);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientManageFriendsGroupResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientManageFriendsGroupResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.eresult = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgClientManageFriendsGroupResponse {
    return { eresult: isSet(object.eresult) ? Number(object.eresult) : 0 };
  },

  toJSON(message: CMsgClientManageFriendsGroupResponse): unknown {
    const obj: any = {};
    message.eresult !== undefined && (obj.eresult = Math.round(message.eresult));
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientManageFriendsGroupResponse>, I>>(
    base?: I,
  ): CMsgClientManageFriendsGroupResponse {
    return CMsgClientManageFriendsGroupResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientManageFriendsGroupResponse>, I>>(
    object: I,
  ): CMsgClientManageFriendsGroupResponse {
    const message = createBaseCMsgClientManageFriendsGroupResponse();
    message.eresult = object.eresult ?? 0;
    return message;
  },
};

function createBaseCMsgClientAddFriendToGroup(): CMsgClientAddFriendToGroup {
  return { groupid: 0, steamiduser: 0 };
}

export const CMsgClientAddFriendToGroup = {
  encode(message: CMsgClientAddFriendToGroup, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.groupid !== 0) {
      writer.uint32(8).int32(message.groupid);
    }
    if (message.steamiduser !== 0) {
      writer.uint32(17).fixed64(message.steamiduser);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientAddFriendToGroup {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientAddFriendToGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.groupid = reader.int32();
          break;
        case 2:
          message.steamiduser = longToNumber(reader.fixed64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgClientAddFriendToGroup {
    return {
      groupid: isSet(object.groupid) ? Number(object.groupid) : 0,
      steamiduser: isSet(object.steamiduser) ? Number(object.steamiduser) : 0,
    };
  },

  toJSON(message: CMsgClientAddFriendToGroup): unknown {
    const obj: any = {};
    message.groupid !== undefined && (obj.groupid = Math.round(message.groupid));
    message.steamiduser !== undefined && (obj.steamiduser = Math.round(message.steamiduser));
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientAddFriendToGroup>, I>>(base?: I): CMsgClientAddFriendToGroup {
    return CMsgClientAddFriendToGroup.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientAddFriendToGroup>, I>>(object: I): CMsgClientAddFriendToGroup {
    const message = createBaseCMsgClientAddFriendToGroup();
    message.groupid = object.groupid ?? 0;
    message.steamiduser = object.steamiduser ?? 0;
    return message;
  },
};

function createBaseCMsgClientAddFriendToGroupResponse(): CMsgClientAddFriendToGroupResponse {
  return { eresult: 0 };
}

export const CMsgClientAddFriendToGroupResponse = {
  encode(message: CMsgClientAddFriendToGroupResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eresult !== 0) {
      writer.uint32(8).uint32(message.eresult);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientAddFriendToGroupResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientAddFriendToGroupResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.eresult = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgClientAddFriendToGroupResponse {
    return { eresult: isSet(object.eresult) ? Number(object.eresult) : 0 };
  },

  toJSON(message: CMsgClientAddFriendToGroupResponse): unknown {
    const obj: any = {};
    message.eresult !== undefined && (obj.eresult = Math.round(message.eresult));
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientAddFriendToGroupResponse>, I>>(
    base?: I,
  ): CMsgClientAddFriendToGroupResponse {
    return CMsgClientAddFriendToGroupResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientAddFriendToGroupResponse>, I>>(
    object: I,
  ): CMsgClientAddFriendToGroupResponse {
    const message = createBaseCMsgClientAddFriendToGroupResponse();
    message.eresult = object.eresult ?? 0;
    return message;
  },
};

function createBaseCMsgClientRemoveFriendFromGroup(): CMsgClientRemoveFriendFromGroup {
  return { groupid: 0, steamiduser: 0 };
}

export const CMsgClientRemoveFriendFromGroup = {
  encode(message: CMsgClientRemoveFriendFromGroup, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.groupid !== 0) {
      writer.uint32(8).int32(message.groupid);
    }
    if (message.steamiduser !== 0) {
      writer.uint32(17).fixed64(message.steamiduser);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientRemoveFriendFromGroup {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientRemoveFriendFromGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.groupid = reader.int32();
          break;
        case 2:
          message.steamiduser = longToNumber(reader.fixed64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgClientRemoveFriendFromGroup {
    return {
      groupid: isSet(object.groupid) ? Number(object.groupid) : 0,
      steamiduser: isSet(object.steamiduser) ? Number(object.steamiduser) : 0,
    };
  },

  toJSON(message: CMsgClientRemoveFriendFromGroup): unknown {
    const obj: any = {};
    message.groupid !== undefined && (obj.groupid = Math.round(message.groupid));
    message.steamiduser !== undefined && (obj.steamiduser = Math.round(message.steamiduser));
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientRemoveFriendFromGroup>, I>>(base?: I): CMsgClientRemoveFriendFromGroup {
    return CMsgClientRemoveFriendFromGroup.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientRemoveFriendFromGroup>, I>>(
    object: I,
  ): CMsgClientRemoveFriendFromGroup {
    const message = createBaseCMsgClientRemoveFriendFromGroup();
    message.groupid = object.groupid ?? 0;
    message.steamiduser = object.steamiduser ?? 0;
    return message;
  },
};

function createBaseCMsgClientRemoveFriendFromGroupResponse(): CMsgClientRemoveFriendFromGroupResponse {
  return { eresult: 0 };
}

export const CMsgClientRemoveFriendFromGroupResponse = {
  encode(message: CMsgClientRemoveFriendFromGroupResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eresult !== 0) {
      writer.uint32(8).uint32(message.eresult);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientRemoveFriendFromGroupResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientRemoveFriendFromGroupResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.eresult = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgClientRemoveFriendFromGroupResponse {
    return { eresult: isSet(object.eresult) ? Number(object.eresult) : 0 };
  },

  toJSON(message: CMsgClientRemoveFriendFromGroupResponse): unknown {
    const obj: any = {};
    message.eresult !== undefined && (obj.eresult = Math.round(message.eresult));
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientRemoveFriendFromGroupResponse>, I>>(
    base?: I,
  ): CMsgClientRemoveFriendFromGroupResponse {
    return CMsgClientRemoveFriendFromGroupResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientRemoveFriendFromGroupResponse>, I>>(
    object: I,
  ): CMsgClientRemoveFriendFromGroupResponse {
    const message = createBaseCMsgClientRemoveFriendFromGroupResponse();
    message.eresult = object.eresult ?? 0;
    return message;
  },
};

function createBaseCMsgClientGetEmoticonList(): CMsgClientGetEmoticonList {
  return {};
}

export const CMsgClientGetEmoticonList = {
  encode(_: CMsgClientGetEmoticonList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientGetEmoticonList {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientGetEmoticonList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): CMsgClientGetEmoticonList {
    return {};
  },

  toJSON(_: CMsgClientGetEmoticonList): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientGetEmoticonList>, I>>(base?: I): CMsgClientGetEmoticonList {
    return CMsgClientGetEmoticonList.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientGetEmoticonList>, I>>(_: I): CMsgClientGetEmoticonList {
    const message = createBaseCMsgClientGetEmoticonList();
    return message;
  },
};

function createBaseCMsgClientEmoticonList(): CMsgClientEmoticonList {
  return { emoticons: [], stickers: [], effects: [] };
}

export const CMsgClientEmoticonList = {
  encode(message: CMsgClientEmoticonList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.emoticons) {
      CMsgClientEmoticonList_Emoticon.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.stickers) {
      CMsgClientEmoticonList_Sticker.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.effects) {
      CMsgClientEmoticonList_Effect.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientEmoticonList {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientEmoticonList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.emoticons.push(CMsgClientEmoticonList_Emoticon.decode(reader, reader.uint32()));
          break;
        case 2:
          message.stickers.push(CMsgClientEmoticonList_Sticker.decode(reader, reader.uint32()));
          break;
        case 3:
          message.effects.push(CMsgClientEmoticonList_Effect.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgClientEmoticonList {
    return {
      emoticons: Array.isArray(object?.emoticons)
        ? object.emoticons.map((e: any) => CMsgClientEmoticonList_Emoticon.fromJSON(e))
        : [],
      stickers: Array.isArray(object?.stickers)
        ? object.stickers.map((e: any) => CMsgClientEmoticonList_Sticker.fromJSON(e))
        : [],
      effects: Array.isArray(object?.effects)
        ? object.effects.map((e: any) => CMsgClientEmoticonList_Effect.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CMsgClientEmoticonList): unknown {
    const obj: any = {};
    if (message.emoticons) {
      obj.emoticons = message.emoticons.map((e) => e ? CMsgClientEmoticonList_Emoticon.toJSON(e) : undefined);
    } else {
      obj.emoticons = [];
    }
    if (message.stickers) {
      obj.stickers = message.stickers.map((e) => e ? CMsgClientEmoticonList_Sticker.toJSON(e) : undefined);
    } else {
      obj.stickers = [];
    }
    if (message.effects) {
      obj.effects = message.effects.map((e) => e ? CMsgClientEmoticonList_Effect.toJSON(e) : undefined);
    } else {
      obj.effects = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientEmoticonList>, I>>(base?: I): CMsgClientEmoticonList {
    return CMsgClientEmoticonList.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientEmoticonList>, I>>(object: I): CMsgClientEmoticonList {
    const message = createBaseCMsgClientEmoticonList();
    message.emoticons = object.emoticons?.map((e) => CMsgClientEmoticonList_Emoticon.fromPartial(e)) || [];
    message.stickers = object.stickers?.map((e) => CMsgClientEmoticonList_Sticker.fromPartial(e)) || [];
    message.effects = object.effects?.map((e) => CMsgClientEmoticonList_Effect.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCMsgClientEmoticonList_Emoticon(): CMsgClientEmoticonList_Emoticon {
  return { name: "", count: 0, timeLastUsed: 0, useCount: 0, timeReceived: 0, appid: 0 };
}

export const CMsgClientEmoticonList_Emoticon = {
  encode(message: CMsgClientEmoticonList_Emoticon, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.count !== 0) {
      writer.uint32(16).int32(message.count);
    }
    if (message.timeLastUsed !== 0) {
      writer.uint32(24).uint32(message.timeLastUsed);
    }
    if (message.useCount !== 0) {
      writer.uint32(32).uint32(message.useCount);
    }
    if (message.timeReceived !== 0) {
      writer.uint32(40).uint32(message.timeReceived);
    }
    if (message.appid !== 0) {
      writer.uint32(48).uint32(message.appid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientEmoticonList_Emoticon {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientEmoticonList_Emoticon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.count = reader.int32();
          break;
        case 3:
          message.timeLastUsed = reader.uint32();
          break;
        case 4:
          message.useCount = reader.uint32();
          break;
        case 5:
          message.timeReceived = reader.uint32();
          break;
        case 6:
          message.appid = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgClientEmoticonList_Emoticon {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      count: isSet(object.count) ? Number(object.count) : 0,
      timeLastUsed: isSet(object.timeLastUsed) ? Number(object.timeLastUsed) : 0,
      useCount: isSet(object.useCount) ? Number(object.useCount) : 0,
      timeReceived: isSet(object.timeReceived) ? Number(object.timeReceived) : 0,
      appid: isSet(object.appid) ? Number(object.appid) : 0,
    };
  },

  toJSON(message: CMsgClientEmoticonList_Emoticon): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.count !== undefined && (obj.count = Math.round(message.count));
    message.timeLastUsed !== undefined && (obj.timeLastUsed = Math.round(message.timeLastUsed));
    message.useCount !== undefined && (obj.useCount = Math.round(message.useCount));
    message.timeReceived !== undefined && (obj.timeReceived = Math.round(message.timeReceived));
    message.appid !== undefined && (obj.appid = Math.round(message.appid));
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientEmoticonList_Emoticon>, I>>(base?: I): CMsgClientEmoticonList_Emoticon {
    return CMsgClientEmoticonList_Emoticon.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientEmoticonList_Emoticon>, I>>(
    object: I,
  ): CMsgClientEmoticonList_Emoticon {
    const message = createBaseCMsgClientEmoticonList_Emoticon();
    message.name = object.name ?? "";
    message.count = object.count ?? 0;
    message.timeLastUsed = object.timeLastUsed ?? 0;
    message.useCount = object.useCount ?? 0;
    message.timeReceived = object.timeReceived ?? 0;
    message.appid = object.appid ?? 0;
    return message;
  },
};

function createBaseCMsgClientEmoticonList_Sticker(): CMsgClientEmoticonList_Sticker {
  return { name: "", count: 0, timeReceived: 0, appid: 0, timeLastUsed: 0, useCount: 0 };
}

export const CMsgClientEmoticonList_Sticker = {
  encode(message: CMsgClientEmoticonList_Sticker, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.count !== 0) {
      writer.uint32(16).int32(message.count);
    }
    if (message.timeReceived !== 0) {
      writer.uint32(24).uint32(message.timeReceived);
    }
    if (message.appid !== 0) {
      writer.uint32(32).uint32(message.appid);
    }
    if (message.timeLastUsed !== 0) {
      writer.uint32(40).uint32(message.timeLastUsed);
    }
    if (message.useCount !== 0) {
      writer.uint32(48).uint32(message.useCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientEmoticonList_Sticker {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientEmoticonList_Sticker();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.count = reader.int32();
          break;
        case 3:
          message.timeReceived = reader.uint32();
          break;
        case 4:
          message.appid = reader.uint32();
          break;
        case 5:
          message.timeLastUsed = reader.uint32();
          break;
        case 6:
          message.useCount = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgClientEmoticonList_Sticker {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      count: isSet(object.count) ? Number(object.count) : 0,
      timeReceived: isSet(object.timeReceived) ? Number(object.timeReceived) : 0,
      appid: isSet(object.appid) ? Number(object.appid) : 0,
      timeLastUsed: isSet(object.timeLastUsed) ? Number(object.timeLastUsed) : 0,
      useCount: isSet(object.useCount) ? Number(object.useCount) : 0,
    };
  },

  toJSON(message: CMsgClientEmoticonList_Sticker): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.count !== undefined && (obj.count = Math.round(message.count));
    message.timeReceived !== undefined && (obj.timeReceived = Math.round(message.timeReceived));
    message.appid !== undefined && (obj.appid = Math.round(message.appid));
    message.timeLastUsed !== undefined && (obj.timeLastUsed = Math.round(message.timeLastUsed));
    message.useCount !== undefined && (obj.useCount = Math.round(message.useCount));
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientEmoticonList_Sticker>, I>>(base?: I): CMsgClientEmoticonList_Sticker {
    return CMsgClientEmoticonList_Sticker.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientEmoticonList_Sticker>, I>>(
    object: I,
  ): CMsgClientEmoticonList_Sticker {
    const message = createBaseCMsgClientEmoticonList_Sticker();
    message.name = object.name ?? "";
    message.count = object.count ?? 0;
    message.timeReceived = object.timeReceived ?? 0;
    message.appid = object.appid ?? 0;
    message.timeLastUsed = object.timeLastUsed ?? 0;
    message.useCount = object.useCount ?? 0;
    return message;
  },
};

function createBaseCMsgClientEmoticonList_Effect(): CMsgClientEmoticonList_Effect {
  return { name: "", count: 0, timeReceived: 0, infiniteUse: false, appid: 0 };
}

export const CMsgClientEmoticonList_Effect = {
  encode(message: CMsgClientEmoticonList_Effect, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.count !== 0) {
      writer.uint32(16).int32(message.count);
    }
    if (message.timeReceived !== 0) {
      writer.uint32(24).uint32(message.timeReceived);
    }
    if (message.infiniteUse === true) {
      writer.uint32(32).bool(message.infiniteUse);
    }
    if (message.appid !== 0) {
      writer.uint32(40).uint32(message.appid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CMsgClientEmoticonList_Effect {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCMsgClientEmoticonList_Effect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.count = reader.int32();
          break;
        case 3:
          message.timeReceived = reader.uint32();
          break;
        case 4:
          message.infiniteUse = reader.bool();
          break;
        case 5:
          message.appid = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CMsgClientEmoticonList_Effect {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      count: isSet(object.count) ? Number(object.count) : 0,
      timeReceived: isSet(object.timeReceived) ? Number(object.timeReceived) : 0,
      infiniteUse: isSet(object.infiniteUse) ? Boolean(object.infiniteUse) : false,
      appid: isSet(object.appid) ? Number(object.appid) : 0,
    };
  },

  toJSON(message: CMsgClientEmoticonList_Effect): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.count !== undefined && (obj.count = Math.round(message.count));
    message.timeReceived !== undefined && (obj.timeReceived = Math.round(message.timeReceived));
    message.infiniteUse !== undefined && (obj.infiniteUse = message.infiniteUse);
    message.appid !== undefined && (obj.appid = Math.round(message.appid));
    return obj;
  },

  create<I extends Exact<DeepPartial<CMsgClientEmoticonList_Effect>, I>>(base?: I): CMsgClientEmoticonList_Effect {
    return CMsgClientEmoticonList_Effect.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CMsgClientEmoticonList_Effect>, I>>(
    object: I,
  ): CMsgClientEmoticonList_Effect {
    const message = createBaseCMsgClientEmoticonList_Effect();
    message.name = object.name ?? "";
    message.count = object.count ?? 0;
    message.timeReceived = object.timeReceived ?? 0;
    message.infiniteUse = object.infiniteUse ?? false;
    message.appid = object.appid ?? 0;
    return message;
  },
};

declare var self: any | undefined;
declare var window: any | undefined;
declare var global: any | undefined;
var tsProtoGlobalThis: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

function bytesFromBase64(b64: string): Uint8Array {
  if (tsProtoGlobalThis.Buffer) {
    return Uint8Array.from(tsProtoGlobalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = tsProtoGlobalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if (tsProtoGlobalThis.Buffer) {
    return tsProtoGlobalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(String.fromCharCode(byte));
    });
    return tsProtoGlobalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new tsProtoGlobalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
